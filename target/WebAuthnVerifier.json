{
  "name": "WebAuthnVerifier",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "serialized_note",
          "type": {
            "kind": "array",
            "length": 0,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "H4sIAAAAAAAA/+1VQQ4CIQws7C5sheg/PGHiA/b/rxK0TSYsnuwejDZpgBaGYWggEpGjl03VZ9qb5jdpy2d2c3ZY5Uie/kt4ToY83YCng7po7VI9VI/VrxJn2tcOy1zEYlnbzEMsSn+Sts1ZjXUKwM0IswT7+ywM2sygkWqzDDQPA83jQPMVMC6Qp+5OzrKGbc92x7tWc914gz7D+Y6oh5Mt5rMekjFmw8igieqn3BPkE+iVjfVysKfi6hj5/bn+NleGGL5Bml8h5rtz4DuXAaN/I0w/T5INPGze7N2np/YAao7Tjj0JAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+XdZZOTZxSH8V0gSd27uLu1ySbZJFVK3alSL6Rk6y1V6qXU3XB390/IuWbCwAt4xb0z3HNl5j9590x+m+yj5z7nZE9Pz7aeM6/e7vuC7nv5wl6VQmyjcI7tVssDtVqn0d+pVCtLy/2tdrNertXbA81Ks1Jv1pf1N6vVTrPWbLTarUa5ValVO5XBeqs62N1wId1nLA+FuxjbKA6Bu3iRu0uxjdIQuEuJ3ef7vV/o5xw5RJ9zWOLvqTeheVQm5mEJzaMzMQ9PaB6TiXlEQvPYTMyFhOZxmZiLCc3jMzGXEponZGIemdA8UWieJDRPFpqnCM1TheZpQvN0oXmG0DxTaJ4lNM8WmucIzXOF5nlC83yh+Sah+WahuSw0V4TmfqG5KjTXhOa60DwgNDeE5qbQ3BKabxGabxWabxOabxea7xCa7xSaFwjNdwnNC4Xmu4Xme4Tme4Xm+4Tm+4XmB4TmB4Xmh4Tmh4XmR4TmR4Xmx4Tmx4XmRULzE0Lzk0LzU0Lz00LzM0Lzs0LzYqH5OaH5eaH5BaH5RaH5JaH5ZaH5FaH5VaF5idC8VGhuC82vCc3LhOaO0DwoNL8uNL8hNL8pNL8lNL8tNL8jNL8rNL8nNL8vNC8Xmj8Qmj8Umj8Smj8Wmj8Rmj8VmlcIzZ8JzZ8LzV8IzV8KzV8JzV8Lzd8Izd8KzSuF5u+E5lVC8/dC8w9C849C809C889C8y9C869C829C8+9C8x9C859C819C899C8z9C879C839C8/9C82qheY3QvFZoXic0rxeaNwjNG4XmTULzZqF5i9C8VWjeJjRvF5p3CM07heZdmZgvSWjenYn50oTmPZmYL0to3puJ+fKE5n2ZmK9IaN6fifnKhOYDmZivSmg+mIn56oTmQ5mYr0loPpyJ+dqE5iOZmK9LaD6aifn6hOZjmZhvSGg+non5xoTmE5mY+xKaTyY093W309s1D4+MiBQixUgpwjUh10hcM3AOzTkl51icc3AM5pjEPpp9Fv/D/Kb5jvvO+ntu6r6PioyOjImMjYyLjI9MiEyMTIpMjkyJTI1Mi0yPzIjMjMyKzI7MicyNzIvMjzDjnpnvfInMBGdGNjOjmaHMTGFm7DYizGBlJikzOplZyQxHZhoy4+/0zDtmoi2MMDOLGVLMVGLGEDN3mEHDTBZmlDCzgxkWzHRgxgE9/xdF6AlPj3R6htNDm57S9FheHKEHLz1p6dFKz1J6eNLTkh6P9DxcEqEnXjtCzzR6iNFTix5T9FyiBxE9eehRQ88WepjQ04MeF/R8WB6hJwBr5Fkzzhpq1hSzxnZFhDWYrElkjR5r1ljDxZom1viw5mVlhDURqyLUzFNDTk01NcbU3FKDSk0mNYrU7FHDRk0XNU7U/FADQ00INRLUDPAMnWfKPGPlmSPP4HgmxTMafhPcw+eeNvd4uee5PcI9Me4Rcc+EewhcU3ONyTUX1yCck3OOyjkb5zAc0znGsc9nH8g+gf+R069TXMw0LzyaAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "do_verify_signature",
      "functionType": "open",
      "isInternal": false,
      "parameters": [
        {
          "name": "_public_key_x",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "private"
        },
        {
          "name": "_public_key_y",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "private"
        },
        {
          "name": "_signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "private"
        },
        {
          "name": "_message_hash",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "struct",
          "path": "aztec::abi::PublicCircuitPublicInputs",
          "fields": [
            {
              "name": "call_context",
              "type": {
                "kind": "struct",
                "path": "aztec::abi::CallContext",
                "fields": [
                  {
                    "name": "msg_sender",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "storage_contract_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "portal_contract_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "function_selector",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_delegate_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_static_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_contract_deployment",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ]
              }
            },
            {
              "name": "args_hash",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "return_values",
              "type": {
                "kind": "array",
                "length": 4,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "contract_storage_update_requests",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "struct",
                  "path": "aztec::abi::ContractStorageUpdateRequest",
                  "fields": [
                    {
                      "name": "storage_slot",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "old_value",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "new_value",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            },
            {
              "name": "contract_storage_read",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "struct",
                  "path": "aztec::abi::ContractStorageRead",
                  "fields": [
                    {
                      "name": "storage_slot",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "value",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            },
            {
              "name": "public_call_stack",
              "type": {
                "kind": "array",
                "length": 4,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "new_commitments",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "new_nullifiers",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "new_l2_to_l1_msgs",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "unencrypted_logs_hash",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "unencrypted_log_preimages_length",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "block_header",
              "type": {
                "kind": "struct",
                "path": "aztec::abi::BlockHeader",
                "fields": [
                  {
                    "name": "note_hash_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nullifier_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "contract_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "l1_to_l2_messages_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "archive_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "public_data_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "global_variables_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "prover_address",
              "type": {
                "kind": "field"
              }
            }
          ]
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "was_verified",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [
        {
          "kind": "boolean"
        }
      ],
      "bytecode": "H4sIAAAAAAAA/8VUSQ7CMAx00qwg8QfuHMoP+gZ+UImKIxLwf0EgVgfTWx3hS1ynmZlMnBgiMvSJjuYwIj/UPEB9qGO/MgLwaWH6F4avWBk02zru6l6sLu9xu+BhAG+1ePB8EJeAK9P3OXKtE15kyHmueLeHeb+wJizw4XquOZp9kGvRIy/20q+Lt0fIM8A3c22EhpZa2AfGdULLP3mjLm9fMBLwcl9E8J35E+jIyjqM0GHo913IkCeoWfFfpDZ3OdDce1qYeO9w7xgD5C17v3jK7+L9cb2Nl+k0jWcDspyQaEEa5vjUcCs5qPHx4RHz+gg1xkkwJ+1R27/ENWIs8QR0U0X5iAcAAA==",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "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E9SdFvHXmqDutAjA1gR1p0UEtiaoOy1CsDVB3WkRg60J6k6LIGxNUHdaRGFrgrrTIgxbE9SdFnHYmqDutAjE1gR1p0UktiaoOy1CsTVB3WkRi60J6k6LYGxNUHdaRGNrgrrTIhxbE9SdFvHYmqDutAjI1gR1p0VEtiaIO11URlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZURlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlZVRlbjjOynX4xaH7b618j1/6N9H+3tYngx+xr8+bHwcXyPEr6H8qOE7878KOH7Pj9K+ETlRwmf1fwo4SqQHyVcX/KjhCtXdpQjTpPzo2Cq7REn4PlRMNX2iFP7/CiYanvEnzTkR8FU2yP+dCQ/Cqfaxp/o5EfhVNv4U6j8KJxqG39ylh+FU23jT/vyo3CqbfwJZX4UTrWNP1XNj8KptvEnwflRONU2/vQ6Pwqn2safuOdH4VTbeJdAfhROtY13NuRH4VTbeDdGfhROtY13kORH4VTbeNdLfhROtY136uRH4VTbeHdRfhROtY13ROVH4VTbeBdXfhROtY13nuVH4VTbeLdcfhROtY13+OVH4VTbeFdifhROtY13UuZH4VTbePdnfhROtY13rOZH4VTbeJdtfhROtY13BudH4VTbeDdzfhROtY13YOdH4VTbeNd4fhROtY13uudH4VTbeHd+fhROtY0bBflRONU2bkHkR+FU27i5kR+FU23jtkl+FE61jRsy+VE41TZu9eRH4VTbuImUH4VTbeP2VH4UTrWNG1/5UTjVluOSHRyX7OC4ZAfHJTs4LtnBcckOjkt2cFyyxnHJGsclaxyXrHFcsvbBVNvGcckaxyVrHJescVyyxnHJGsclaxyXrHFcssZxyRrHJWscl6xxXLLGcckaxyVrHJescVyyxnHJGsclaxyXrHFcssZxyRrHJWscl6xxXLLGcckaxyVrHJescVyyxnHJGsclaxyXrHFcssZxyRrHJWscl6xxXLLGcckaxyVrHJescVyyxnHJGsclaxyXrHFcssZxyRrHJWscl6xxXLLGcckaxyVrHJescVyyxnHJGsclaxyXrHFcssZxyRrHJWscl6xxXLLGcckaxyVrHJescVyyxnHJGsclaxyXrHFcssZxyRrHJWscl6xxXLLGcckaxyVrHJescVyyxnHJGsclaxyXrHFcssZxyRrHJWscl6xxXLLGcckaxyVrHJescVyyxnHJGsclaxyXrHFcssZxyRrHJWscl6xzXLLOcck6xyXrHJesfzDVtnNcss5xyTrHJescl6xzXLLOcck6xyXrHJesc1yyznHJOscl6xyXrHNcss5xyTrHJescl6xzXLLOcck6xyXrHJesc1yyznHJOscl6xyXrHNcss5xyTrHJescl6xzXLLOcck6xyXrHJesc1yyznHJOscl6xyXrHNcss5xyTrHJescl6xzXLLOcck6xyXrHJesc1yyznHJOscl6xyXrHNcss5xyTrHJescl6xzXLLOcck6xyXrHJesc1yyznHJOscl6xyXrHNcss5xyTrHJescl6xzXLLOcck6xyXrHJesc1yyznHJOscl6xyXrHNcss5xyTrHJescl6xzXLLOcck6xyXrHJesc1yyznHJOscl6xyXrHNcss5xyTrHJescl6xzXLLOcck6xyXrHJesc1yyznHJOsclGxyXbHBcssFxyQbHJRsfTLUdHJdscFyywXHJBsclGxyXbHBcssFxyQbHJRscl2xwXLLBcckGxyUbHJdscFyywXHJBsclGxyXbHBcssFxyQbHJRscl2xwXLLBcckGxyUbHJdscFyywXHJBsclGxyXbHBcssFxyQbHJRscl2xwXLLBcckGxyUbHJdscFyywXHJBsclGxyXbHBcssFxyQbHJRscl2xwXLLBcckGxyUbHJdscFyywXHJBsclGxyXbHBcssFxyQbHJRscl2xwXLLBcckGxyUbHJdscFyywXHJBsclGxyXbHBcssFxyQbHJRscl2xwXLLBcckGxyUbHJdscFyywXHJBsclGxyXbHBcssFxyQbHJRscl2xwXLLBcckGxyUbHJdscFyywXHJBsclGxyXbHBcssFxyQbHJRscl2xwXLLBccmM45IZxyUzjktmHJfMPphqaxyXzDgumXFcMuO4ZMZxyYzjkhnHJTOOS2Ycl8w4LplxXDLjuGTGccmM45IZxyUzjktmHJfMOC6ZcVwy47hkxnHJjOOSGcclM45LZhyXzDgumXFcMuO4ZMZxyYzjkhnHJTOOS2Ycl8w4LplxXDLjuGTGccmM45IZxyUzjktmHJfMOC6ZcVwy47hkxnHJjOOSGcclM45LZhyXzDgumXFcMuO4ZMZxyYzjkhnHJTOOS2Ycl8w4LplxXDLjuGTGccmM45IZxyUzjktmHJfMOC6ZcVwy47hkxnHJjOOSGcclM45LZhyXzDgumXFcMuO4ZMZxyYzjkhnHJTOOS2Ycl8w4LplxXDLjuGTGccmM45IZxyUzjktmHJfMOC6ZcVwy47hkxnHJjOOSGcclmxyXbHJcsslxySbHJZsfTLWdHJdsclyyyXHJJsclmxyXbHJcsslxySbHJZscl2xyXLLJcckmxyWbHJdsclyyyXHJJsclmxyXbHJcsslxySbHJZscl2xyXLLJcckmxyWbHJdsclyyyXHJJsclmxyXbHJcsslxySbHJZscl2xyXLLJcckmxyWbHJdsclyyyXHJJsclmxyXbHJcsslxySbHJZscl2xyXLLJcckmxyWbHJdsclyyyXHJJsclmxyXbHJcsslxySbHJZscl2xyXLLJcckmxyWbHJdsclyyyXHJJsclmxyXbHJcsslxySbHJZscl2xyXLLJcckmxyWbHJdsclyyyXHJJsclmxyXbHJcsslxySbHJZscl2xyXLLJcckmxyWbHJdsclyyyXHJJsclmxyXbHJcsslxySbHJZscl2xyXLLJccmc45I5xyVzjkvmHJfMP5hq6xyXzDkumXNcMue4ZM5xyZzjkjnHJXOOS+Ycl8w5LplzXDLnuGTOccmc45I5xyVzjkvmHJfMOS6Zc1wy57hkznHJnOOSOcclc45L5hyXzDkumXNcMue4ZM5xyZzjkjnHJXOOS+Ycl8w5LplzXDLnuGTOccmc45I5xyVzjkvmHJfMOS6Zc1wy57hkznHJnOOSOcclc45L5hyXzDkumXNcMue4ZM5xyZzjkjnHJXOOS+Ycl8w5LplzXDLnuGTOccmc45I5xyVzjkvmHJfMOS6Zc1wy57hkznHJnOOSOcclc45L5hyXzDkumXNcMue4ZM5xyZzjkjnHJXOOS+Ycl8w5LplzXDLnuGTOccmc45I5xyVzjkvmHJfMOS6Zc1wy57hkznHJnOOSOcYlWz+jVNv1M0q1XT+jVNv1M0q1XT+jVNv1M0q1XT+jVNv1M0q1XT+jVNv1M061xbhkKwqn2mJcshWFU20xLtmKwqm2GJdsReFUW4xLtqJwqi3GJVtRONUW45KtKJxqi3HJVhROtcW4ZCsKp9piXLIVhVNtMS7ZisKpthiXbEXhVFuMS7aicKotxiVbUTjVFuOSrSicaotxyVYUTrXFuGQrCqfaYlyyFYVTbTEu2YrCqbYYl2xF4VRbjEu2onCqLcYlW1E41Rbjkq0onGqLcclWFE61xbhkKwqn2mJcshWFU20xLtmKwqm2GJdsReFUW4xLtqJwqi3GJVtRwtX2nBA3vr4mhCvX14RwffmaEK4CXxPCZ/VrQvhEfU0I3/dfEy7vTvu+e3PYxaTL++hu0uWO30y6Nk/uJl3u/LTjnOSf+qu3ehnf7/Qyxvgx9vCrgzHm150+f7Zus+9xLu8rJY6NrzhW/necr0tc3onvXuLy3n33Epd3+7uXuDwf717i8kS9e4nL8/fuJS5P66uXuPYc3r3E40pwf4n8033tG7x7ifzTfe0HvHuJ/NN93c//7iXyT/d1//2blyjXffXvXiL9dJfrPvh3L5F+ussn/XSX6370dy+RfrrLdf/4u5dIP93lut/71Utc93G/e4n8033dd/3uJfJP93Wf9LuXyD/d133N714i/3Rf9yG/e4n8033dN/zuJfJP93Wf77uXyD/d1325714i/3Rf99G+e4n8033d9/ruJfJP93Wf6ruXyD/d132l714i/3Rf94G+e4n8033dt/nuJfJP93Wf5buXyD/d132R714i/3Rf9zG+e4n8033dd/juJfJP93Wf4LuXyD/d1319714i/3Rf9+G9e4n8033dN/fuJfJP93Wf27uXyD/d131p714i/3Rf95G9e4n8033d9/XuJfJP93Wf1ruXyD/d131V714i/3Rf90G9e4n8033dt/TuJfJP93UH07uXyD/d111S714i/3Rfd2K9e4n8033d7fXuJfJP93U32buXyD/d151q714i/3Tn96qV/F61kt+rVvJ71Up+r1rJ71Ur+b1qJb9XreT3qpX8XrWS36tW8nvVSn6vWsnvVSv5vWolv1et5PeqlfxetZrfq1bze9Vqfq9aze9Vq5/0013ze9Vqfq9aze9Vq/m9ajW/V63m96rV/F61mt+rVvN71Wp+r1rN71Wr+b1qNb9Xreb3qtX8XrWa36tW83vVan6vWs3vVav5vWo1v1et5veq1fxetZrfq1bze9Vqfq9aze9Vq/m9ajW/V63m96rV/F61mt+rVvN71Wp+r9qMf3/b14TL++PXJoh2+3zyjWXl02b7+iOv/+/fR3v9vv6Dr2oIrf/g+xdC6z/4CpvI+k++BSy0/oMvmwmt/+AbZELrP/hamND64RP2G9d/8AUuofWTz++TL7YKrf/k/LZSv761Yv1/v1z/yfkNrP/ke6VC6z85v5H1n5zfyPpPzm9k/SfnN7L+k/MbWf/J+Y2s/+T8RtZPPr/xLzX6bes/eet9aP3k8/vk/fSh9ZPP75M3yYfWTz6/T975Hlo/+fw+eTt7aP3k8/vkPeqh9ZPP75M3nofWTz6/T95NHlo/+fw+eYt4aP3k8/vkfd+h9ZPP75M3c4fWF7+ycMZfiv01QUUu8Vcpf00I30NfE5KhyJN3DQfW9ycvEA6tnwtF/MmrfkPr50IR/+RCEX/ypt3Q+rlQxJ+8Eze0fu759Sdvr42s/+SVtIGi7k/eMxtaP/dDmT95I2xo/dwPZf7k3a2h9XM/lPmTt6yG1s/9UOZP3ocaWf/JS05D6yef3yevIw2tn3x+n7w4NLR+8vl98orP0PrJ5/fJyzhD6yef3yevzQytn3x+n7zgMrR+8vl98irK0PrJ5/fJSyND6yef3yevdwytn3x+n7yIMbR+8vl98srE0PpiH42rfTQeb1v5mhC+5b4miG/r8OROEU/uFPHkThFP7hTx5E4RT+4U8eROEU/uFPFHnSKR9ZOhyKNOkcj6yec3uVPEkztFPLlTxJM7RTy5U8STO0U8uVPEkztFPLlTxJM7RTy5U8STO0U8uVPEkztFPLlTxJM7RTy5U8STO0U8uVPEkztFPLlTxJM7RTy5U8STO0U8uVPEkztFPLlTxJM7RTy5U8TjnSK/cf3k83v9NTEvrp98ftU+Glf7aDzetvI/E45PvA/la4LWbbQmpEKRtX4qFFnrp0KRtX4qFFnrp0KRtX4qFFnrp0KRtX4qFDk+jzpFIuunQpG1fvL5fdQpElk/taiv9VM/lK31Uz+UrfVTP5St9VM/lK31Uz+UHZ/cTpG1fuqHsrV+6oeytX7qh7K1fvL5ze0UWesnn9/cTpG1fvL5ze0UOT65nSJr/eTzm9spstZPPr+5nSJr/eTzm9spstZPPr+5nSJr/eTzm9spstZPPr+5nSJr/eTzG28s+Y3rJ5/fR1//Ellf66NZE7Q+muNz3bZy+2U8a+LlrReZeHlPjfH1RUH26T+b9iPo5a1yP+3yDrifdrmx99Mu9+tXpv31r/8NWuTyRg==",
      "eJzNlUEKwjAQRe8y6yKZmcS0vYq4KFpBkCq2u9K7WyHaisGClPB3Cfwf3mLmpafL9VB152vTUtmT2Tgqdz21t6p53tuuundUFi7PqG6O4ynnIaPT+VJTOZ6+kixbCVFW1SmrRSStzoawFm6W5WGfjSxbIBYPxJIDsRRALGyQYBgJRpBgFAnGIsEg2ZeR9MtI/mUkATOSgQXJwIJkYEEysCAZWJAMLEkNbA2HsBXzARN52b8YOPdT1voAntTWa4InNfua4El/gT/B5zP+Bk/6Y6wIrlFtifGhJNZ+b7RG9bJUimpgqRRdwaVSdPyXStHR+1EahgeZX51M"
    ],
    "fileMap": {
      "1": {
        "source": "contract WebAuthnVerifier {\n  use dep::std::ecdsa_secp256k1;\n  use dep::aztec::{\n    context::{PrivateContext, PublicContext, Context},\n    state_vars::public_state::PublicState,\n    types::type_serialization::bool_serialization::{BoolSerializationMethods, BOOL_SERIALIZED_LEN}\n  };\n\n  struct Storage {\n    verified: PublicState<bool, BOOL_SERIALIZED_LEN>\n  }\n  impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                verified: PublicState::new(context, 1, BoolSerializationMethods)\n            }\n        }\n    }\n\n  #[aztec(private)]\n  fn constructor() {\n  }\n  \n  #[aztec(public)]\n  fn do_verify_signature(_public_key_x: [u8; 32],\n    _public_key_y: [u8; 32],\n    _signature: [u8; 64],\n    _message_hash: [u8; 32]) {\n    let test = ecdsa_secp256k1::verify_signature(_public_key_x, _public_key_y, _signature, _message_hash);\n    storage.verified.write(!test);\n\n  }\n\n  unconstrained fn was_verified() -> bool {\n    storage.verified.read()\n  }\n\n  unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, serialized_note: [Field; 0]) -> [Field; 4] {\n      [0, 0, 0, 0]\n  }\n}",
        "path": "/Users/cat/Documents/Work/private_counter_from_docs/contracts/counter/src/main.nr"
      },
      "33": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "75": {
        "source": "global ARGS_LENGTH: Field = 16;\nglobal RETURN_VALUES_LENGTH: Field = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_COMMITMENTS_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as commitments and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX ≥ MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_COMMITMENTS_PER_TX ≥ MAX_NEW_COMMITMENTS_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX ≥ MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_COMMITMENTS_PER_CALL: Field = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: Field = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: Field = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: Field = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: Field = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: Field = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: Field = 16;\nglobal MAX_READ_REQUESTS_PER_CALL: Field = 32;\nglobal MAX_PENDING_READ_REQUESTS_PER_CALL: Field = 32;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_COMMITMENTS_PER_TX: Field = 64;\nglobal MAX_NEW_NULLIFIERS_PER_TX: Field = 64;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: Field = 8;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 8;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: Field = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_TX: Field = 16;\nglobal MAX_NEW_CONTRACTS_PER_TX: Field = 1;\nglobal MAX_OPTIONALLY_REVEALED_DATA_LENGTH_PER_TX: Field = 4;\nglobal MAX_READ_REQUESTS_PER_TX: Field = 128;\nglobal MAX_PENDING_READ_REQUESTS_PER_TX: Field = 128;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: Field = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: Field = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: Field = 16;\n// TODO(961): Use this constant everywhere instead of hard-coded \"2\".\nglobal KERNELS_PER_BASE_ROLLUP: Field = 2;\nglobal MAX_NEW_NULLIFIERS_PER_BASE_ROLLUP: Field = 128;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_BASE_ROLLUP: Field = 32;\nglobal MAX_PUBLIC_DATA_READS_PER_BASE_ROLLUP: Field = 32;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: Field = 3;\nglobal FUNCTION_TREE_HEIGHT: Field = 5;\nglobal CONTRACT_TREE_HEIGHT: Field = 16;\nglobal NOTE_HASH_TREE_HEIGHT: Field = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: Field = 254;\nglobal NULLIFIER_TREE_HEIGHT: Field = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: Field = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: Field = 8;\n\n// SUB-TREES RELATED CONSTANTS\nglobal CONTRACT_SUBTREE_HEIGHT: Field = 1;\nglobal CONTRACT_SUBTREE_SIBLING_PATH_LENGTH: Field = 15;\nglobal NOTE_HASH_SUBTREE_HEIGHT: Field = 7;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: Field = 25;\nglobal NULLIFIER_SUBTREE_HEIGHT: Field = 7;\nglobal ARCHIVE_HEIGHT: Field = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: Field = 13;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: Field = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: Field = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\nglobal MAPPING_SLOT_PEDERSEN_SEPARATOR: Field = 4;\nglobal NUM_FIELDS_PER_SHA256: Field = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue bellow is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_LENGTH: Field = 8;\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: Field = 26;\nglobal MAX_NOTE_FIELDS_LENGTH: Field = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: Field = 23;\nglobal MAX_NOTES_PER_PAGE: Field = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: Field = 212;\nglobal CALL_CONTEXT_LENGTH: Field = 7;\nglobal BLOCK_HEADER_LENGTH: Field = 7;\nglobal FUNCTION_DATA_LENGTH: Field = 4;\nglobal CONTRACT_DEPLOYMENT_DATA_LENGTH: Field = 6;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we\n// should change this constant as well as the offsets in private_call_stack_item.nr\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: Field = 155;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: Field = 3;\nglobal CONTRACT_STORAGE_READ_LENGTH: Field = 2;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: Field = 142;\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: Field = 674;\nglobal EMPTY_NULLIFIED_COMMITMENT: Field = 1000000;\nglobal CALL_PRIVATE_FUNCTION_RETURN_SIZE: Field = 161;\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH: Field = 87;\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH: Field = 144;\nglobal COMMITMENTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 4096;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 4096;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 128;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 104;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 128;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 128;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n ≤ 8                         | 0 < hash_index ≤ 32  |\n * | MID       | 8 < n ≤ 16                    | 32 < hash_index ≤ 40 |\n * | HIGH      | 16 < n ≤ 48                   | 40 < hash_index ≤ 48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size ≤ 8\nglobal GENERATOR_INDEX__COMMITMENT = 1;\nglobal GENERATOR_INDEX__COMMITMENT_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_COMMITMENT = 3;\nglobal GENERATOR_INDEX__SILOED_COMMITMENT = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\n// Indices with size ≤ 16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size ≤ 44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\n",
        "path": "/protocol_types/constants.nr"
      },
      "92": {
        "source": "use dep::protocol_types::constants::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    BLOCK_HEADER_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__BLOCK_HASH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_header: BlockHeader,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:block-header\nstruct BlockHeader {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    archive_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:block-header\n\nimpl BlockHeader {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; BLOCK_HEADER_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.archive_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn deserialize(deserialized: [Field; BLOCK_HEADER_LENGTH]) -> Self {\n        BlockHeader {\n            note_hash_tree_root: deserialized[0],\n            nullifier_tree_root: deserialized[1],\n            contract_tree_root: deserialized[2],\n            l1_to_l2_messages_tree_root: deserialized[3],\n            archive_root: deserialized[4],\n            public_data_tree_root: deserialized[5],\n            global_variables_hash: deserialized[6],\n        }\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, archive_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n\n    pub fn block_hash(self) -> Field {\n        // TODO(#3442): Unify the ordering in `BlockHeader::serialize` function and the ordering\n        // in the block hash preimage --> This requires changes in the circuits.\n        let inputs = [\n            self.global_variables_hash,\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.public_data_tree_root\n        ];\n        pedersen_hash(inputs, GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_header.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_header.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/aztec/abi.nr"
      },
      "94": {
        "source": "use dep::protocol_types::constants::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    BlockHeader,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n    get_block_header::get_block_header,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_header: BlockHeader,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_header: inputs.block_header,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_block_header(self, block_number: u32) -> BlockHeader {\n        get_block_header(block_number, self)\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.block_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, self.this_address(), self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_header: BlockHeader {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    archive_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_header: BlockHeader::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_header: BlockHeader,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_header: inputs.block_header,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_header: self.inputs.block_header,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_header.l1_to_l2_messages_tree_root, this, self.this_portal_address(), self.chain_id(), self.version(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}\n",
        "path": "/aztec/context.nr"
      },
      "95": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse dep::protocol_types::constants::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    // TODO(#1205) This is probably not the right index to use\n    pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    pedersen_hash_with_separator(inputs, hash_index)\n}\n",
        "path": "/aztec/hash.nr"
      },
      "131": {
        "source": "#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<T, N>(storage_slot: Field, deserialize: fn ([Field; N]) -> T) -> T {\n    let fields = storage_read_oracle_wrapper(storage_slot);\n    deserialize(fields)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\n// TODO: Remove return value.\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n",
        "path": "/aztec/oracle/storage.nr"
      },
      "139": {
        "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse crate::types::type_serialization::TypeSerializationInterface;\nuse dep::std::option::Option;\n\n// docs:start:public_state_struct\nstruct PublicState<T, T_SERIALIZED_LEN> {\n    context: Context,\n    storage_slot: Field,\n    serialization_methods: TypeSerializationInterface<T, T_SERIALIZED_LEN>,\n}\n// docs:end:public_state_struct\n\nimpl<T, T_SERIALIZED_LEN> PublicState<T, T_SERIALIZED_LEN> {\n    // docs:start:public_state_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n        serialization_methods: TypeSerializationInterface<T, T_SERIALIZED_LEN>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicState {\n            context,\n            storage_slot,\n            serialization_methods,\n        }\n    }\n    // docs:end:public_state_struct_new\n\n    // docs:start:public_state_struct_read\n    pub fn read(self) -> T {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        storage_read(self.storage_slot, self.serialization_methods.deserialize)\n    }\n    // docs:end:public_state_struct_read\n\n    // docs:start:public_state_struct_write\n    pub fn write(self, value: T) {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let serialize = self.serialization_methods.serialize;\n        let fields = serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_state_struct_write\n}\n",
        "path": "/aztec/state_vars/public_state.nr"
      },
      "147": {
        "source": "use crate::types::type_serialization::TypeSerializationInterface;\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\n\nfn deserializeBool(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n    fields[0] as bool\n}\n\nfn serializeBool(value: bool) -> [Field; BOOL_SERIALIZED_LEN] {\n    [value as Field]\n}\n\nglobal BoolSerializationMethods = TypeSerializationInterface {\n    deserialize: deserializeBool,\n    serialize: serializeBool,\n};\n",
        "path": "/aztec/types/type_serialization/bool_serialization.nr"
      }
    }
  }
}